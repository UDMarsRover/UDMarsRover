from picamera2 import Picamera2
import cv2
import cv2.aruco as aruco
import time
from threading import Thread
from flask import Flask, Response
import numpy as np
import imutils

# --- GLOBAL VARIABLES & FLASK SETUP ---
outputFrame = None
lock = threading.Lock()
app = Flask(__name__)

# --- CAMERA AND ARUCO SETUP ---
picam2 = Picamera2()
# Configure for a smaller, faster resolution 
picam2.configure(picam2.create_preview_configuration(main={"size": (640, 480)}))
picam2.start()
time.sleep(2) # Allow camera to warm up

aruco_dict = aruco.getPredefinedDictionary(aruco.DICT_5X5_100)
aruco_params = aruco.DetectorParameters()
detector = aruco.ArucoDetector(aruco_dict, aruco_params)

# --- CAMERA/DETECTION THREAD FUNCTION ---
def camera_loop():
    global outputFrame
    while True:
        # 1. Capture Frame
        frame = picam2.capture_array()
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) 
        
        # 2. Process (Detection)
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        corners, ids, rejected = detector.detectMarkers(gray_frame)
        
        # Draw box and ID if markers are found (for the stream)
        if ids is not None and len(ids) > 0:
            frame = aruco.drawDetectedMarkers(frame, corners, ids)
            # You can still print to SSH terminal if needed
            # for i in range(len(ids)):
            #     print(f"Detected ID: {ids[i][0]}")

        # 3. Prepare Frame for Streaming
        with lock:
            # Encode frame to JPEG format for streaming
            (flag, encodedImage) = cv2.imencode(".jpg", frame)
            # Ensure the frame was successfully encoded
            if not flag:
                continue
            outputFrame = encodedImage.tobytes()

        time.sleep(0.05) # Throttle to 20 FPS max

# --- FLASK STREAMING ROUTES ---

@app.route("/video_feed")
def video_feed():
    # Return the response generated by the generator function
    return Response(generate(),
                    mimetype = "multipart/x-mixed-replace; boundary=frame")

def generate():
    # Grab global reference to the output frame
    global outputFrame
    
    while True:
        # Acquire lock to ensure we are reading a consistent frame
        with lock:
            if outputFrame is None:
                continue

            # Yield the output frame in the sequence required by M-JPEG
            yield(b'--frame\r\n'
                  b'Content-Type: image/jpeg\r\n\r\n' + outputFrame + b'\r\n')

# --- MAIN EXECUTION ---
if __name__ == '__main__':
    # Start the camera/detection thread
    t = Thread(target=camera_loop)
    t.daemon = True
    t.start()
    
    # Start the Flask web server on all interfaces (0.0.0.0) on port 8000
    print("Starting Flask streaming server on port 8000...")
    app.run(host='0.0.0.0', port='8000', debug=False, threaded=True)

    # Clean up (This part won't run until Flask is stopped)
    picam2.close()